var searchIndex = JSON.parse('{\
"libslide":{"doc":"","i":[[3,"EvaluatorContext","libslide","",null,null],[12,"rule_blacklist","","",0,null],[5,"scan","","",null,[[["into",8],["string",3]],[["vec",3],["token",3]]]],[5,"parse_expression","","",null,[[["vec",3],["token",3]]]],[5,"parse_expression_pattern","","",null,[[["vec",3],["token",3]]]],[5,"evaluate","","Evaluates an expression to as simplified a form as…",null,[[["evaluatorcontext",3],["stmt",4]],[["expr",4],["result",4],["box",3]]]],[0,"scanner","","",null,null],[3,"Scanner","libslide::scanner","",null,null],[12,"input","","",1,null],[12,"output","","",1,null],[5,"scan","","",null,[[["into",8],["string",3]],[["vec",3],["token",3]]]],[0,"types","","",null,null],[3,"Token","libslide::scanner::types","",null,null],[12,"ty","","",2,null],[4,"TokenType","","",null,null],[13,"Float","","",3,null],[13,"Plus","","",3,null],[13,"Minus","","",3,null],[13,"Mult","","",3,null],[13,"Div","","",3,null],[13,"Mod","","",3,null],[13,"Exp","","",3,null],[13,"Equal","","",3,null],[13,"OpenParen","","",3,null],[13,"CloseParen","","",3,null],[13,"OpenBracket","","",3,null],[13,"CloseBracket","","",3,null],[13,"Variable","","",3,null],[13,"VariablePattern","","",3,null],[13,"ConstPattern","","",3,null],[13,"AnyPattern","","",3,null],[13,"Invalid","","",3,null],[13,"EOF","","",3,null],[11,"new","","",2,[[["tokentype",4]]]],[11,"new","libslide::scanner","",1,[[["into",8],["string",3]],["scanner",3]]],[11,"scan","","",1,[[]]],[11,"scan_symbol","","",1,[[]]],[11,"scan_num","","",1,[[]]],[11,"scan_var_str","","",1,[[],["string",3]]],[11,"scan_var","","",1,[[]]],[11,"scan_var_pattern","","",1,[[]]],[11,"scan_const_pattern","","",1,[[]]],[11,"scan_any_pattern","","",1,[[]]],[0,"parser","libslide","",null,null],[0,"test_utils","libslide::parser","",null,null],[0,"expression_parser","","",null,null],[3,"ExpressionParser","libslide::parser::expression_parser","",null,null],[12,"_input","","",4,null],[12,"_errors","","",4,null],[12,"seen","","",4,null],[5,"parse","","",null,[[["vec",3],["token",3]]]],[11,"assignment","","",4,[[["string",3]],["stmt",4]]],[11,"parse_pattern","","",4,[[["string",3]],["expr",4]]],[0,"expression_pattern_parser","libslide::parser","",null,null],[3,"ExpressionPatternParser","libslide::parser::expression_pattern_parser","",null,null],[12,"_input","","",5,null],[12,"_errors","","",5,null],[12,"seen","","",5,null],[5,"parse","","",null,[[["vec",3],["token",3]]]],[8,"Parser","libslide::parser","",null,null],[16,"Expr","","",6,null],[16,"Error","","",6,null],[10,"new","","",6,[[["vec",3],["token",3]]]],[10,"errors","","",6,[[],["vec",3]]],[10,"input","","",6,[[],["peekiter",3]]],[10,"parse","","",6,[[]]],[10,"parse_float","","",6,[[]]],[10,"parse_variable","","",6,[[["string",3]]]],[10,"parse_var_pattern","","",6,[[["string",3]]]],[10,"parse_const_pattern","","",6,[[["string",3]]]],[10,"parse_any_pattern","","",6,[[["string",3]]]],[10,"parse_open_paren","","",6,[[]]],[10,"parse_open_bracket","","",6,[[]]],[10,"finish_expr","","",6,[[],["rc",3]]],[11,"done","","",6,[[]]],[11,"expr","","",6,[[],["rc",3]]],[11,"add_sub_term","","",6,[[],["rc",3]]],[11,"mul_divide_mod_term","","",6,[[],["rc",3]]],[11,"exp_term","","",6,[[],["rc",3]]],[11,"num_term","","",6,[[],["rc",3]]],[0,"partial_evaluator","libslide","",null,null],[5,"evaluate","libslide::partial_evaluator","Evaluates an expression to as simplified a form as…",null,[[["evaluatorcontext",3],["stmt",4]],[["expr",4],["result",4],["box",3]]]],[0,"types","","",null,null],[3,"EvaluatorContext","libslide::partial_evaluator::types","",null,null],[12,"rule_blacklist","","",0,null],[11,"with_blacklist","libslide","",0,[[]]],[0,"evaluator_rules","","",null,null],[0,"pattern_match","libslide::evaluator_rules","",null,null],[3,"PatternMatch","libslide::evaluator_rules::pattern_match","Represents pattern-matched replacements betwen a rule and…",null,null],[12,"map","","",7,null],[8,"MatchRule","","",null,null],[10,"match_rule","","Pattern matches a rule template against an expression. If…",8,[[["rc",3],["exprpat",4],["rc",3]],[["patternmatch",3],["option",4]]]],[11,"try_merge","","Merges two `PatternMatch`. If the `PatternMatch` are of…",7,[[["patternmatch",3]],[["patternmatch",3],["option",4]]]],[11,"insert","","",7,[[["rc",3],["rc",3]],[["rc",3],["option",4]]]],[0,"registry","libslide::evaluator_rules","",null,null],[3,"RuleSet","libslide::evaluator_rules::registry","Set of unbuilt rules.",null,null],[12,"rules","","",9,null],[12,"custom_rules","","",9,null],[3,"BuildRuleErrors","","",null,null],[12,"errors","","",10,null],[4,"RuleName","","",null,null],[13,"UnwrapExplicitParens","","",11,null],[13,"UnwrapExplicitBrackets","","",11,null],[13,"Add","","",11,null],[13,"Subtract","","",11,null],[13,"Multiply","","",11,null],[13,"Divide","","",11,null],[13,"Modulo","","",11,null],[13,"Exponentiate","","",11,null],[13,"Posate","","",11,null],[13,"Negate","","",11,null],[13,"MultiplicateIdentity","","",11,null],[13,"AdditiveIdentity","","",11,null],[13,"AdditiveInverse","","",11,null],[13,"ReorderConstants","","",11,null],[13,"DistributeNegation","","",11,null],[13,"FoldNegatedAddition","","",11,null],[5,"get_all_rules","","",null,[[],[["rulename",4],["unbuiltrule",4],["hashmap",3]]]],[0,"fn_rules","","",null,null],[5,"add","libslide::evaluator_rules::registry::fn_rules","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"subtract","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"multiply","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"divide","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"modulo","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"exponentiate","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"posate","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[5,"negate","","",null,[[["rc",3],["expr",4]],[["option",4],["rc",3]]]],[11,"build","libslide::evaluator_rules::registry","Creates a list of `Rules`s from the unbuilt rule set.",9,[[],[["vec",3],["buildruleerrors",3],["result",4]]]],[11,"remove","","Remove a named rule from the rule set.",9,[[["rulename",4]]]],[11,"insert_custom","","Insert a custom unbuilt rule into the rule set.",9,[[["unbuiltrule",4],["into",8]]]],[11,"get_bootstrapping_rules","","Retrieves a set of rules to be used in bootstrapping other…",9,[[],[["vec",3],["rule",4]]]],[11,"get_boostrap_blacklist","","Retrieves a set of rules to be excluded from being…",9,[[],[["hashset",3],["option",4]]]],[0,"rule","libslide::evaluator_rules","",null,null],[3,"PatternMap","libslide::evaluator_rules::rule","A mapping between two expression patterns.",null,null],[12,"from","","",12,null],[12,"to","","",12,null],[3,"UnresolvedMapping","","",null,null],[12,"map","","",13,null],[12,"unresolved_pats","","",13,null],[4,"Rule","","",null,null],[13,"PatternMap","","",14,null],[13,"Evaluate","","",14,null],[5,"fn_name","","",null,[[]]],[11,"from_str","","Converts a string representation of a rule to a…",12,[[]]],[11,"bootstrap","","Bootstraps a `PatternMap` rule with a one-pass application…",12,[[]]],[11,"validate","","Checks a `PatternMap` is resolvable, returning an error if…",12,[[],[["unresolvedmapping",3],["option",4]]]],[11,"from_fn","","",14,[[]]],[0,"unbuilt_rule","libslide::evaluator_rules","",null,null],[4,"UnbuiltRule","libslide::evaluator_rules::unbuilt_rule","An unbuilt rule, generally used to express a rule in a…",null,null],[13,"S","","An expression-mapping rule.",15,null],[13,"F","","A function rule.",15,null],[0,"grammar","libslide","",null,null],[3,"Assignment","libslide::grammar","",null,null],[12,"var","","",16,null],[12,"rhs","","",16,null],[3,"BinaryExpr","","",null,null],[12,"op","","",17,null],[12,"lhs","","",17,null],[12,"rhs","","",17,null],[3,"UnaryExpr","","",null,null],[12,"op","","",18,null],[12,"rhs","","",18,null],[4,"Stmt","","",null,null],[13,"Expr","","",19,null],[13,"Assignment","","",19,null],[4,"Expr","","",null,null],[13,"Const","","",20,null],[13,"Var","","",20,null],[13,"BinaryExpr","","",20,null],[13,"UnaryExpr","","",20,null],[13,"Parend","","An expression wrapped in parentheses",20,null],[13,"Bracketed","","An expression wrapped in brackets",20,null],[4,"BinaryOperator","","",null,null],[13,"Plus","","",21,null],[13,"Minus","","",21,null],[13,"Mult","","",21,null],[13,"Div","","",21,null],[13,"Mod","","",21,null],[13,"Exp","","",21,null],[4,"UnaryOperator","","",null,null],[13,"SignPositive","","",22,null],[13,"SignNegative","","",22,null],[0,"pattern","","",null,null],[4,"ExprPat","libslide::grammar::pattern","",null,null],[13,"Const","","",23,null],[13,"VarPat","","Pattern matching a variable",23,null],[13,"ConstPat","","Pattern matching a constant",23,null],[13,"AnyPat","","Pattern matching any expression",23,null],[13,"BinaryExpr","","",23,null],[13,"UnaryExpr","","",23,null],[13,"Parend","","",23,null],[13,"Bracketed","","",23,null],[0,"transformer","libslide::grammar","",null,null],[8,"Transformer","libslide::grammar::transformer","A trait for transforming one grammar into another. This…",null,null],[10,"transform","","",24,[[]]],[8,"Grammar","libslide::grammar","",null,null],[8,"Expression","","",null,null],[10,"is_const","","",25,[[]]],[11,"complexity","","",20,[[]]],[0,"math","libslide","",null,null],[0,"gcd","libslide::math","",null,null],[5,"gcd","libslide::math::gcd","Calculates the GCD for (u, v) ∈ (Z, Z).",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[5,"binary_gcd","","The [Binary GCD] algorithm, or Stein\'s algorithm.…",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[5,"euclidean_gcd","","The [Euclidean GCD] algorithm. Implemented ∀ (u, v) ∈ (Z,…",null,[[["primint",8],["unsigned",8]],[["primint",8],["unsigned",8]]]],[0,"utils","libslide","",null,null],[0,"grammar","libslide::utils","",null,null],[4,"UnflattenStrategy","libslide::utils::grammar","",null,null],[13,"Left","","",26,null],[13,"Right","","",26,null],[5,"get_symmetric_expressions","","",null,[[["rc",3],["expr",4]],[["rc",3],["vec",3]]]],[5,"get_flattened_binary_args","","",null,[[["rc",3],["expr",4],["binaryoperator",4]],[["rc",3],["vec",3]]]],[5,"negate","","",null,[[["rc",3],["expr",4]],[["rc",3],["expr",4]]]],[5,"unflatten_binary_expr","","",null,[[["unflattenstrategy",4],["binaryoperator",4]],["rc",3]]],[5,"unique_pats","","Returns all unique patterns in a pattern expression.",null,[[["rc",3]],[["hashset",3],["rc",3]]]],[5,"normalize","","",null,[[["rc",3],["expr",4]],[["rc",3],["expr",4]]]],[0,"hash","libslide::utils","",null,null],[5,"hash","libslide::utils::hash","",null,[[]]],[0,"iter","libslide::utils","",null,null],[3,"PeekingTakeWhile","libslide::utils::iter","A [`TakeWhile`]-like struct that tests a predicate by…",null,null],[12,"peeker","","A mutable reference to the underlying iterator is taken…",27,null],[12,"predicate","","",27,null],[3,"PeekIter","","An iterator that supports arbitrary-length peeking.",null,null],[12,"iter","","",28,null],[12,"lookahead","","A store of items we had to consume from the iterator for…",28,null],[11,"new","","",27,[[["peekiter",3]]]],[11,"new","","",28,[[["intoiter",3]]]],[11,"peek","","Returns a reference to the next value in the iterator,…",28,[[],["option",4]]],[11,"peek_map_n","","Returns a deque of up to `n` peeked items mapped over a…",28,[[],["vecdeque",3]]],[11,"collect_while","","Collects items in the iteration while `predicate` returns…",28,[[]]],[11,"push_front","","Adds an item to the front of the current iteration.",28,[[]]],[0,"string","libslide::utils","",null,null],[5,"indent","libslide::utils::string","Indents all lines of a string with `n` spaces.",null,[[["into",8],["string",3]],["string",3]]],[8,"StringUtils","","",null,null],[10,"substring","","",29,[[]]],[11,"from","libslide","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","libslide::scanner","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","libslide::scanner::types","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"to_string","","",2,[[],["string",3]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","libslide::parser::expression_parser","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","libslide::parser::expression_pattern_parser","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::pattern_match","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::registry","",9,[[]]],[11,"into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_string","","",10,[[],["string",3]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::rule","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"to_string","","",12,[[],["string",3]]],[11,"borrow","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_string","","",13,[[],["string",3]]],[11,"borrow","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"borrow","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","libslide::grammar","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"to_string","","",16,[[],["string",3]]],[11,"borrow","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"borrow","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"to_string","","",18,[[],["string",3]]],[11,"borrow","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_owned","","",19,[[]]],[11,"clone_into","","",19,[[]]],[11,"to_string","","",19,[[],["string",3]]],[11,"borrow","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"to_string","","",20,[[],["string",3]]],[11,"borrow","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"to_string","","",21,[[],["string",3]]],[11,"borrow","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"into","","",22,[[]]],[11,"to_owned","","",22,[[]]],[11,"clone_into","","",22,[[]]],[11,"to_string","","",22,[[],["string",3]]],[11,"borrow","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","libslide::grammar::pattern","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"to_string","","",23,[[],["string",3]]],[11,"borrow","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","libslide::utils::grammar","",26,[[]]],[11,"into","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","libslide::utils::iter","",27,[[]]],[11,"into","","",27,[[]]],[11,"into_iter","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"into_iter","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"new","libslide::parser::expression_parser","",4,[[["vec",3],["token",3]]]],[11,"errors","","",4,[[],["vec",3]]],[11,"input","","",4,[[],["peekiter",3]]],[11,"parse","","",4,[[],["stmt",4]]],[11,"parse_float","","",4,[[]]],[11,"parse_variable","","",4,[[["string",3]]]],[11,"parse_var_pattern","","",4,[[["string",3]]]],[11,"parse_const_pattern","","",4,[[["string",3]]]],[11,"parse_any_pattern","","",4,[[["string",3]]]],[11,"parse_open_paren","","",4,[[]]],[11,"parse_open_bracket","","",4,[[]]],[11,"finish_expr","","",4,[[],["rc",3]]],[11,"new","libslide::parser::expression_pattern_parser","",5,[[["vec",3],["token",3]]]],[11,"errors","","",5,[[],["vec",3]]],[11,"input","","",5,[[],["peekiter",3]]],[11,"parse","","",5,[[],[["rc",3],["exprpat",4]]]],[11,"parse_float","","",5,[[]]],[11,"parse_variable","","",5,[[["string",3]]]],[11,"parse_var_pattern","","",5,[[["string",3]]]],[11,"parse_const_pattern","","",5,[[["string",3]]]],[11,"parse_any_pattern","","",5,[[["string",3]]]],[11,"parse_open_paren","","",5,[[]]],[11,"parse_open_bracket","","",5,[[]]],[11,"finish_expr","","",5,[[],["rc",3]]],[11,"match_rule","libslide::evaluator_rules::pattern_match","",7,[[["rc",3],["exprpat",4],["rc",3],["expr",4]],[["patternmatch",3],["option",4]]]],[11,"match_rule","","",7,[[["rc",3],["exprpat",4]],[["patternmatch",3],["option",4]]]],[11,"transform","","Transforms a pattern expression into an expression by…",7,[[["rc",3],["exprpat",4]],[["rc",3],["expr",4]]]],[11,"transform","","",7,[[["rc",3],["exprpat",4]],[["rc",3],["exprpat",4]]]],[11,"transform","libslide::evaluator_rules::rule","Attempts to apply a rule on a target expression by",14,[[["rc",3],["expr",4]],[["rc",3],["expr",4]]]],[11,"transform","","Bootstraps a rule with another (or possibly the same) rule.",14,[[["rc",3],["exprpat",4]],[["rc",3],["exprpat",4]]]],[11,"is_const","libslide::grammar::pattern","",23,[[]]],[11,"is_const","libslide::grammar","",20,[[]]],[11,"from","libslide::evaluator_rules::unbuilt_rule","",15,[[]]],[11,"from","libslide::grammar::pattern","",23,[[["binaryexpr",3]]]],[11,"from","","",23,[[["unaryexpr",3]]]],[11,"from","libslide::grammar","",19,[[["expr",4]]]],[11,"from","","",19,[[["assignment",3]]]],[11,"from","","",20,[[]]],[11,"from","","",20,[[["binaryexpr",3]]]],[11,"from","","",20,[[["unaryexpr",3]]]],[11,"next","libslide::utils::iter","",27,[[],["option",4]]],[11,"next","","",28,[[],["option",4]]],[11,"clone","libslide::scanner::types","",3,[[],["tokentype",4]]],[11,"clone","","",2,[[],["token",3]]],[11,"clone","libslide::evaluator_rules::registry","",11,[[],["rulename",4]]],[11,"clone","libslide::evaluator_rules::rule","",12,[[],["patternmap",3]]],[11,"clone","libslide::evaluator_rules::unbuilt_rule","",15,[[],["unbuiltrule",4]]],[11,"clone","libslide::grammar::pattern","",23,[[],["exprpat",4]]],[11,"clone","libslide::grammar","",19,[[],["stmt",4]]],[11,"clone","","",16,[[],["assignment",3]]],[11,"clone","","",20,[[],["expr",4]]],[11,"clone","","",21,[[],["binaryoperator",4]]],[11,"clone","","",17,[[],["binaryexpr",3]]],[11,"clone","","",22,[[],["unaryoperator",4]]],[11,"clone","","",18,[[],["unaryexpr",3]]],[11,"default","libslide","",0,[[]]],[11,"default","libslide::evaluator_rules::pattern_match","",7,[[]]],[11,"default","libslide::evaluator_rules::registry","Constructs the default rule set.",9,[[]]],[11,"cmp","","",11,[[],["ordering",4]]],[11,"cmp","libslide::grammar","",20,[[],["ordering",4]]],[11,"eq","libslide::scanner::types","",3,[[["tokentype",4]]]],[11,"ne","","",3,[[["tokentype",4]]]],[11,"eq","","",2,[[["token",3]]]],[11,"ne","","",2,[[["token",3]]]],[11,"eq","libslide::evaluator_rules::registry","",11,[[["rulename",4]]]],[11,"eq","libslide::grammar::pattern","",23,[[["exprpat",4]]]],[11,"eq","libslide::grammar","",20,[[["expr",4]]]],[11,"ne","","",20,[[["expr",4]]]],[11,"eq","","",21,[[["binaryoperator",4]]]],[11,"eq","","",17,[[["binaryexpr",3]]]],[11,"ne","","",17,[[["binaryexpr",3]]]],[11,"eq","","",22,[[["unaryoperator",4]]]],[11,"eq","","",18,[[["unaryexpr",3]]]],[11,"ne","","",18,[[["unaryexpr",3]]]],[11,"partial_cmp","libslide::evaluator_rules::registry","",11,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","libslide::grammar","",20,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",21,[[],[["ordering",4],["option",4]]]],[11,"fmt","libslide::scanner::types","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::registry","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::rule","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::pattern","",23,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::scanner::types","",2,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::registry","",10,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::evaluator_rules::rule","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar::pattern","",23,[[["formatter",3]],["result",6]]],[11,"fmt","libslide::grammar","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],["result",6]]],[11,"hash","libslide::evaluator_rules::registry","",11,[[]]],[11,"hash","libslide::grammar::pattern","",23,[[]]],[11,"hash","libslide::grammar","",20,[[]]],[11,"hash","","",21,[[]]],[11,"hash","","",17,[[]]],[11,"hash","","",22,[[]]],[11,"hash","","",18,[[]]],[11,"try_from","","",21,[[["token",3]],["result",4]]],[11,"try_from","","",22,[[["token",3]],["result",4]]]],"p":[[3,"EvaluatorContext"],[3,"Scanner"],[3,"Token"],[4,"TokenType"],[3,"ExpressionParser"],[3,"ExpressionPatternParser"],[8,"Parser"],[3,"PatternMatch"],[8,"MatchRule"],[3,"RuleSet"],[3,"BuildRuleErrors"],[4,"RuleName"],[3,"PatternMap"],[3,"UnresolvedMapping"],[4,"Rule"],[4,"UnbuiltRule"],[3,"Assignment"],[3,"BinaryExpr"],[3,"UnaryExpr"],[4,"Stmt"],[4,"Expr"],[4,"BinaryOperator"],[4,"UnaryOperator"],[4,"ExprPat"],[8,"Transformer"],[8,"Expression"],[4,"UnflattenStrategy"],[3,"PeekingTakeWhile"],[3,"PeekIter"],[8,"StringUtils"]]},\
"num_traits":{"doc":"Numeric traits for generic mathematics","i":[[3,"ParseFloatError","num_traits","",null,null],[12,"kind","","",0,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",1,null],[13,"Invalid","","",1,null],[5,"clamp","","A value bounded by a minimum and a maximum",null,[[["partialord",8]],["partialord",8]]],[5,"clamp_min","","A value bounded by a minimum value",null,[[["partialord",8]],["partialord",8]]],[5,"clamp_max","","A value bounded by a maximum value",null,[[["partialord",8]],["partialord",8]]],[0,"bounds","","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",2,[[]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[]]],[0,"cast","num_traits","",null,null],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",null,[[["numcast",8]],[["numcast",8],["option",4]]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`. If the value…",3,[[],["option",4]]],[11,"to_i8","","Converts the value of `self` to an `i8`. If the value…",3,[[],["option",4]]],[11,"to_i16","","Converts the value of `self` to an `i16`. If the value…",3,[[],["option",4]]],[11,"to_i32","","Converts the value of `self` to an `i32`. If the value…",3,[[],["option",4]]],[10,"to_i64","","Converts the value of `self` to an `i64`. If the value…",3,[[],["option",4]]],[11,"to_i128","","Converts the value of `self` to an `i128`. If the value…",3,[[],["option",4]]],[11,"to_usize","","Converts the value of `self` to a `usize`. If the value…",3,[[],["option",4]]],[11,"to_u8","","Converts the value of `self` to a `u8`. If the value…",3,[[],["option",4]]],[11,"to_u16","","Converts the value of `self` to a `u16`. If the value…",3,[[],["option",4]]],[11,"to_u32","","Converts the value of `self` to a `u32`. If the value…",3,[[],["option",4]]],[10,"to_u64","","Converts the value of `self` to a `u64`. If the value…",3,[[],["option",4]]],[11,"to_u128","","Converts the value of `self` to a `u128`. If the value…",3,[[],["option",4]]],[11,"to_f32","","Converts the value of `self` to an `f32`. If the value…",3,[[],["option",4]]],[11,"to_f64","","Converts the value of `self` to an `f64`. If the value…",3,[[],["option",4]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Converts an `isize` to return an optional value of this…",4,[[],["option",4]]],[11,"from_i8","","Converts an `i8` to return an optional value of this type.…",4,[[],["option",4]]],[11,"from_i16","","Converts an `i16` to return an optional value of this…",4,[[],["option",4]]],[11,"from_i32","","Converts an `i32` to return an optional value of this…",4,[[],["option",4]]],[10,"from_i64","","Converts an `i64` to return an optional value of this…",4,[[],["option",4]]],[11,"from_i128","","Converts an `i128` to return an optional value of this…",4,[[],["option",4]]],[11,"from_usize","","Converts a `usize` to return an optional value of this…",4,[[],["option",4]]],[11,"from_u8","","Converts an `u8` to return an optional value of this type.…",4,[[],["option",4]]],[11,"from_u16","","Converts an `u16` to return an optional value of this…",4,[[],["option",4]]],[11,"from_u32","","Converts an `u32` to return an optional value of this…",4,[[],["option",4]]],[10,"from_u64","","Converts an `u64` to return an optional value of this…",4,[[],["option",4]]],[11,"from_u128","","Converts an `u128` to return an optional value of this…",4,[[],["option",4]]],[11,"from_f32","","Converts a `f32` to return an optional value of this type.…",4,[[],["option",4]]],[11,"from_f64","","Converts a `f64` to return an optional value of this type.…",4,[[],["option",4]]],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted…",5,[[["toprimitive",8]],["option",4]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",null,null],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[]]],[0,"float","num_traits","",null,null],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with…",null,null],[10,"infinity","","Returns positive infinity.",7,[[]]],[10,"neg_infinity","","Returns negative infinity.",7,[[]]],[10,"nan","","Returns NaN.",7,[[]]],[10,"neg_zero","","Returns `-0.0`.",7,[[]]],[10,"min_value","","Returns the smallest finite value that this type can…",7,[[]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",7,[[]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[]]],[10,"max_value","","Returns the largest finite value that this type can…",7,[[]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",7,[[]]],[10,"classify","","Returns the floating point category of the number. If only…",7,[[],["fpcategory",4]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",7,[[]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",7,[[]]],[11,"trunc","","Return the integer part of a number.",7,[[]]],[11,"fract","","Returns the fractional part of a number.",7,[[]]],[11,"abs","","Computes the absolute value of `self`. Returns…",7,[[]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",7,[[]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",7,[[]]],[11,"min","","Returns the minimum of the two numbers.",7,[[]]],[11,"max","","Returns the maximum of the two numbers.",7,[[]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",7,[[]]],[11,"powi","","Raise a number to an integer power.",7,[[]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",7,[[]]],[8,"Float","","Generic trait for floating point numbers",null,null],[10,"nan","","Returns the `NaN` value.",8,[[]]],[10,"infinity","","Returns the infinite value.",8,[[]]],[10,"neg_infinity","","Returns the negative infinite value.",8,[[]]],[10,"neg_zero","","Returns `-0.0`.",8,[[]]],[10,"min_value","","Returns the smallest finite value that this type can…",8,[[]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",8,[[]]],[11,"epsilon","","Returns epsilon, a small positive value.",8,[[]]],[10,"max_value","","Returns the largest finite value that this type can…",8,[[]]],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",8,[[]]],[10,"is_infinite","","Returns `true` if this value is positive infinity or…",8,[[]]],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",8,[[]]],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,…",8,[[]]],[10,"classify","","Returns the floating point category of the number. If only…",8,[[],["fpcategory",4]]],[10,"floor","","Returns the largest integer less than or equal to a number.",8,[[]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",8,[[]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",8,[[]]],[10,"trunc","","Return the integer part of a number.",8,[[]]],[10,"fract","","Returns the fractional part of a number.",8,[[]]],[10,"abs","","Computes the absolute value of `self`. Returns…",8,[[]]],[10,"signum","","Returns a number that represents the sign of `self`.",8,[[]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",8,[[]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",8,[[]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",8,[[]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",8,[[]]],[10,"powi","","Raise a number to an integer power.",8,[[]]],[10,"powf","","Raise a number to a floating point power.",8,[[]]],[10,"sqrt","","Take the square root of a number.",8,[[]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",8,[[]]],[10,"exp2","","Returns `2^(self)`.",8,[[]]],[10,"ln","","Returns the natural logarithm of the number.",8,[[]]],[10,"log","","Returns the logarithm of the number with respect to an…",8,[[]]],[10,"log2","","Returns the base 2 logarithm of the number.",8,[[]]],[10,"log10","","Returns the base 10 logarithm of the number.",8,[[]]],[11,"to_degrees","","Converts radians to degrees.",8,[[]]],[11,"to_radians","","Converts degrees to radians.",8,[[]]],[10,"max","","Returns the maximum of the two numbers.",8,[[]]],[10,"min","","Returns the minimum of the two numbers.",8,[[]]],[10,"abs_sub","","The positive difference of two numbers.",8,[[]]],[10,"cbrt","","Take the cubic root of a number.",8,[[]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",8,[[]]],[10,"sin","","Computes the sine of a number (in radians).",8,[[]]],[10,"cos","","Computes the cosine of a number (in radians).",8,[[]]],[10,"tan","","Computes the tangent of a number (in radians).",8,[[]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",8,[[]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",8,[[]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",8,[[]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",8,[[]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",8,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",8,[[]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",8,[[]]],[10,"sinh","","Hyperbolic sine function.",8,[[]]],[10,"cosh","","Hyperbolic cosine function.",8,[[]]],[10,"tanh","","Hyperbolic tangent function.",8,[[]]],[10,"asinh","","Inverse hyperbolic sine function.",8,[[]]],[10,"acosh","","Inverse hyperbolic cosine function.",8,[[]]],[10,"atanh","","Inverse hyperbolic tangent function.",8,[[]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",8,[[]]],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",9,[[]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",9,[[]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",9,[[]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",9,[[]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",9,[[]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",9,[[]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",9,[[]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",9,[[]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",9,[[]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",9,[[]]],[10,"LN_10","","Return `ln(10.0)`.",9,[[]]],[10,"LN_2","","Return `ln(2.0)`.",9,[[]]],[10,"LOG10_E","","Return `log10(e)`.",9,[[]]],[10,"LOG2_E","","Return `log2(e)`.",9,[[]]],[10,"PI","","Return Archimedes’ constant `π`.",9,[[]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",9,[[]]],[11,"TAU","","Return the full circle constant `τ`.",9,[[]]],[0,"identities","num_traits","",null,null],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",null,[[],["zero",8]]],[5,"one","","Returns the multiplicative identity, `1`.",null,[[],["one",8]]],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`. #…",10,[[]]],[11,"set_zero","","Sets `self` to the additive identity element of `Self`, `0`.",10,[[]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",10,[[]]],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",11,[[]]],[11,"set_one","","Sets `self` to the multiplicative identity element of…",11,[[]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",11,[[]]],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","Generic trait for primitive integers.",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of…",12,[[]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",12,[[]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",12,[[]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",12,[[]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",12,[[]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",12,[[]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",12,[[]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",12,[[]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",12,[[]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",12,[[]]],[10,"swap_bytes","","Reverses the byte order of the integer.",12,[[]]],[10,"from_be","","Convert an integer from big endian to the target\'s…",12,[[]]],[10,"from_le","","Convert an integer from little endian to the target\'s…",12,[[]]],[10,"to_be","","Convert `self` to big endian from the target\'s endianness.",12,[[]]],[10,"to_le","","Convert `self` to little endian from the target\'s…",12,[[]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",12,[[]]],[0,"ops","num_traits","",null,null],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",13,[[],["option",4]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",14,[[],["option",4]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",15,[[],["option",4]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",16,[[],["option",4]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",null,null],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",17,[[],["option",4]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can\'t…",null,null],[10,"checked_neg","","Negates a number, returning `None` for results that can\'t…",18,[[],["option",4]]],[8,"CheckedShl","","Performs a left shift that returns `None` on shifts larger…",null,null],[10,"checked_shl","","Checked shift left. Computes `self << rhs`, returning…",19,[[],["option",4]]],[8,"CheckedShr","","Performs a right shift that returns `None` on shifts…",null,null],[10,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning…",20,[[],["option",4]]],[0,"inv","num_traits::ops","",null,null],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse,…",null,null],[16,"Output","","The result after applying the operator.",21,null],[10,"inv","","Returns the multiplicative inverse of `self`.",21,[[]]],[0,"mul_add","num_traits::ops","",null,null],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",null,null],[16,"Output","","The resulting type after applying the fused multiply-add.",22,null],[10,"mul_add","","Performs the fused multiply-add operation.",22,[[]]],[8,"MulAddAssign","","The fused multiply-add assignment operation.",null,null],[10,"mul_add_assign","","Performs the fused multiply-add operation.",23,[[]]],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",24,[[]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",24,[[]]],[0,"wrapping","num_traits::ops","",null,null],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",null,null],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",25,[[]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",null,null],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",26,[[]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",null,null],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",27,[[]]],[8,"WrappingShl","","Performs a left shift that does not panic.",null,null],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",28,[[]]],[8,"WrappingShr","","Performs a right shift that does not panic.",null,null],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",29,[[]]],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",null,[[["mul",8],["clone",8],["one",8]],[["mul",8],["clone",8],["one",8]]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",null,[[["checkedmul",8],["clone",8],["one",8]],[["checkedmul",8],["clone",8],["one",8],["option",4]]]],[8,"Pow","","Binary operator for raising a value to a power.",null,null],[16,"Output","","The result after applying the operator.",30,null],[10,"pow","","Returns `self` to the power `rhs`.",30,[[]]],[0,"real","num_traits","",null,null],[8,"Real","num_traits::real","A trait for real number types that do not necessarily have…",null,null],[10,"min_value","","Returns the smallest finite value that this type can…",31,[[]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",31,[[]]],[10,"epsilon","","Returns epsilon, a small positive value.",31,[[]]],[10,"max_value","","Returns the largest finite value that this type can…",31,[[]]],[10,"floor","","Returns the largest integer less than or equal to a number.",31,[[]]],[10,"ceil","","Returns the smallest integer greater than or equal to a…",31,[[]]],[10,"round","","Returns the nearest integer to a number. Round half-way…",31,[[]]],[10,"trunc","","Return the integer part of a number.",31,[[]]],[10,"fract","","Returns the fractional part of a number.",31,[[]]],[10,"abs","","Computes the absolute value of `self`. Returns…",31,[[]]],[10,"signum","","Returns a number that represents the sign of `self`.",31,[[]]],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`,…",31,[[]]],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`,…",31,[[]]],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only…",31,[[]]],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",31,[[]]],[10,"powi","","Raise a number to an integer power.",31,[[]]],[10,"powf","","Raise a number to a real number power.",31,[[]]],[10,"sqrt","","Take the square root of a number.",31,[[]]],[10,"exp","","Returns `e^(self)`, (the exponential function).",31,[[]]],[10,"exp2","","Returns `2^(self)`.",31,[[]]],[10,"ln","","Returns the natural logarithm of the number.",31,[[]]],[10,"log","","Returns the logarithm of the number with respect to an…",31,[[]]],[10,"log2","","Returns the base 2 logarithm of the number.",31,[[]]],[10,"log10","","Returns the base 10 logarithm of the number.",31,[[]]],[10,"to_degrees","","Converts radians to degrees.",31,[[]]],[10,"to_radians","","Converts degrees to radians.",31,[[]]],[10,"max","","Returns the maximum of the two numbers.",31,[[]]],[10,"min","","Returns the minimum of the two numbers.",31,[[]]],[10,"abs_sub","","The positive difference of two numbers.",31,[[]]],[10,"cbrt","","Take the cubic root of a number.",31,[[]]],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle…",31,[[]]],[10,"sin","","Computes the sine of a number (in radians).",31,[[]]],[10,"cos","","Computes the cosine of a number (in radians).",31,[[]]],[10,"tan","","Computes the tangent of a number (in radians).",31,[[]]],[10,"asin","","Computes the arcsine of a number. Return value is in…",31,[[]]],[10,"acos","","Computes the arccosine of a number. Return value is in…",31,[[]]],[10,"atan","","Computes the arctangent of a number. Return value is in…",31,[[]]],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and…",31,[[]]],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number,…",31,[[]]],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if…",31,[[]]],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than…",31,[[]]],[10,"sinh","","Hyperbolic sine function.",31,[[]]],[10,"cosh","","Hyperbolic cosine function.",31,[[]]],[10,"tanh","","Hyperbolic tangent function.",31,[[]]],[10,"asinh","","Inverse hyperbolic sine function.",31,[[]]],[10,"acosh","","Inverse hyperbolic cosine function.",31,[[]]],[10,"atanh","","Inverse hyperbolic tangent function.",31,[[]]],[0,"sign","num_traits","",null,null],[5,"abs","num_traits::sign","Computes the absolute value.",null,[[["signed",8]],["signed",8]]],[5,"abs_sub","","The positive difference of two numbers.",null,[[["signed",8]],["signed",8]]],[5,"signum","","Returns the sign of the number.",null,[[["signed",8]],["signed",8]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",null,null],[10,"abs","","Computes the absolute value.",32,[[]]],[10,"abs_sub","","The positive difference of two numbers.",32,[[]]],[10,"signum","","Returns the sign of the number.",32,[[]]],[10,"is_positive","","Returns true if the number is positive and false if the…",32,[[]]],[10,"is_negative","","Returns true if the number is negative and false if the…",32,[[]]],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1`…",null,null],[16,"FromStrRadixErr","","",33,null],[10,"from_str_radix","","Convert from a string and radix <= 36.",33,[[],["result",4]]],[8,"NumOps","","The trait for types implementing basic numeric operations",null,null],[8,"NumRef","","The trait for `Num` types which also implement numeric…",null,null],[8,"RefNum","","The trait for references which implement numeric…",null,null],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",null,null],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",null,null],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",null,null],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"to_string","","",0,[[],["string",3]]],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]]],"p":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"Float"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Real"],[8,"Signed"],[8,"Num"]]},\
"slide":{"doc":"","i":[[5,"main","slide","",null,[[],[["string",3],["result",4]]]]],"p":[]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);